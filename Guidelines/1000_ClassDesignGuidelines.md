<!--
NOTE: Requires Markdown Extra. See http://michelf.ca/projects/php-markdown/extra/
 --> 

#クラス・デザインガイドライン

###クラスやインターフェイスはひとつの役割だけを持つようにする (AV1000) ![](images/1.png)

A クラスやインターフェイスはそれが参加しているシステムの中で単一の目的を持つべきである。一般的にクラスは、emailやISBNのようなプリミティブ型、業務を抽象化したもの、プレーンなデータ構造、もしくは、複数のクラス間での対話によるオーケストレーションを行う責任があるものなどが存在するが、それらが組み合わさることはない。このルールは、SOLID原則のひとつである[単一責務の原則](http://www.objectmentor.com/resources/articles/srp.pdf)として知られている。

**Tip** Andという単語が含まれるクラスは明らかにルール違反である。

**Tip** クラスの意図を伝えるために[デザインパターン](http://en.wikipedia.org/wiki/Design_pattern_(computer_science))を使用する。もしひとつのデザインパターンを割り当てることができない場合、ひとつ以上のことをしようとしている可能性がある。

**Note** プリミティブ型を表現するクラスを作る場合は、不変(immutable)にすることで非常にシンプルにすることができる。

###使えるオブジェクトを返すコンストラクターだけを作成する (AV1001) ![](images/3.png)

オブジェクトが使用可能になるまでに追加でプロパティに値をセットする必要がないように設計する。ただし、コンストラクターに3つより多いパラメータが必要 (AV1561に違反している) な場合、そのクラスは責務を持ちすぎている (AV1000に違反) 可能性がある。

###インターフェイスは小さく、集中的であるべきである (AV1003) ![](images/2.png)

インターフェイスは、システムの中のインターフェイスの目的と役割を明確に説明できる名前を持つべきである。同じクラスで使用するからと言って、ひとつのインターフェイスに関連性の薄いメンバーを組み合わせてはならない。メンバーの責務を元にメンバーを分離して、呼び出し元は特定のタスクに関連するインターフェイスを呼び出すか実装するだけでよい。このルールは[インターフェイス分離原則](http://www.objectmentor.com/resources/articles/isp.pdf).として一般的に知られている。

###複数の実装をサポートするためにベースクラスではなくインターフェイスを使用する (AV1004) ![](images/3.png)

クラスに拡張ポイントを公開したい場合、ベースクラスではなくインターフェイスを公開した方がよい。拡張ポイントのユーザーが望まない動作をするベースクラスの実装を強要したくないはずだ。ただし、開始点としてデフォルト実装(abstract)を提供することで便利になるかもしれない。

###クラスを分離するためにインターフェイスを使用する (AV1005) ![](images/2.png)

インターフェイスはクラスを切り離すために非常に効果的なメカニズムである。

- 双方向の関係性を防ぐことができる 
- 別の実装に置き換えることが容易である
- 本番環境以外で高価な外部サービスやリソースを一時的にスタブに置き換えることができる
- ユニットテストでダミー実装やフェイクオブジェクトに置き換えることができる
- 特定のインターフェイスが要求されても、依存性注入フレームワークを使って、どのクラスを選択するかを集中管理できる 

###静的クラスを避ける (AV1008) ![](images/3.png)

拡張メソッドコンテナをのぞいて静的なクラスは粗悪な設計のコードに繋がることが多い。またすごいハックツールを使いたい場合を除いて、テストの分離が難しくなる。

**Note** 静的クラスがどうしても必要な場合、Staticとしてマークしてコンパイラがインスタンスメンバーとクラスをインスタンス化することを防ぐようにする。これで明示的なprivateコンストラクターを作成する必要がなくなる。

###継承メンバーを newキーワードで隠すべきではない (AV1010) ![](images/1.png)

new キーワードは、もっとも本質的なオブジェクト指向原則のひとつである[ポリモーフィズム](http://en.wikipedia.org/wiki/Polymorphism_in_object-oriented_programming)を壊すだけでなく、 サブクラスを理解することがより難しくなる。以下の2つのクラスについて考えてみよう:

	public class Book
	{
		public virtual void Print()
	 	{
			Console.WriteLine("Printing Book");
		}
	}

	public class PocketBook : Book
	{
		public new void Print()
		{
			Console.WriteLine("Printing PocketBook");
		}
	}

これは、通常のクラス階層からは予期できない振る舞いが発生する:

	PocketBook pocketBook = new PocketBook();  
	
	pocketBook.Print(); 		// "Printing PocketBook "と出力される

	((Book)pocketBook).Print(); 	// "Printing Book"と出力される

このようにベースクラスを参照するか、継承クラスを参照するかによってPrintメソッドの呼び出し結果に違いを生み出すべきではない。

###派生クラスは、ベースクラスであるかのうように処理を実行できなくてはならない (AV1011) ![](images/2.png)

言い換えれば、派生クラスを参照された場合でも、派生クラスを知らなくてもベースクラスの参照と同じように使用できるようにするべきである。このルールに違反している有名な例として、ベースクラスのいくつかのメソッドをオーバーライドしたときにNotImplementedException をスローするというものである。少ない微妙な例では、ベースクラスが期待している振る舞いを尊重していない。

**Note** このルールは、[S.O.L.I.D.](http://www.lostechies.com/blogs/chad_myers/archive/2008/03/07/pablo-s-topic-of-the-month-march-solid-principles.aspx) 原則のひとつであるリスコフの置換原則としても知られている。

###ベースクラスから派生クラスを参照しない (AV1013) ![](images/1.png)

ベースクラスがサブクラスに依存することは、適切なオブジェクト指向設計に反する上に、ほかの開発者が新しい派生クラスを追加することを阻むことになる。

###オブジェクトが依存するほかのオブジェクトを公開するのを避ける (AV1014) ![](images/2.png)

あなたの書いたコードにこれがある場合、[デメテルの法則](http://en.wikipedia.org/wiki/Law_of_Demeter)に違反している可能性がある。

	someObject.SomeProperty.GetChild().Foo()

呼び出し元が後方にあるオブジェクトにアクセスするために、誤って公開されたプロパティやメソッドを使用してしまう可能性があるため、オブジェクトは依存するほかのクラスを公開するべきではない。これをしてしまうと、あなたが使っているクラスと結合することができるようになってしまい、将来それを置き換える機会を制限してしまう。

**Note** 流れるようなインターフェイスパターンを使ったクラスはこのルールに違反しているように見えるが、メソッドチェーンを可能にするために自分自身を返しているだけである。

**例外** 制御の反転や依存性注入フレームワークは依存性をpublicプロパティで公開する必要があることがある。このプロパティが依存性注入にのみ使われているのであれば、私は違反だとは考えない。

### 双方向の依存を避ける (AV1020) ![](images/1.png)

これは、2つのクラスがお互いのpublicメンバーやお互いの内部動作に依存しているということである。リファクタリングや2つのうちのひとつを置き換えるためには、両方を変更するという予期しない多くの作業が必要になる。依存性をなくす確実な方法は、一方のクラスのインターフェイスに依存性注入を使用することである。

**例外** [ドメイン駆動設計](http://domaindrivendesign.org/)で定義されたドメインモデルは実生活の関係性によって双方向の関係になることがある。このようなケースでは、本当に必要かどうかを確認して、それでも必要な場合はそれを維持する。

###クラスは状態と振る舞いを持つべきである (AV1025) ![](images/1.png)

コードベースにデータだけのクラスが大量にある場合、多くの振る舞いを持つ（静的な）クラス （AV1008を参照）.がいくつかあるのではないだろうか。このセクションで説明されているオブジェクト指向の原則を使って、それが適用されるデータの近くにロジックを移動する。

例外このルールの唯一の例外は、[データ転送オブジェクト（Data Transfer Objects）](http://martinfowler.com/eaaCatalog/dataTransferObject.html)と呼ばれる通信チャネルでデータを転送するために使用されるクラスか、メソッドのパラメータをラップするクラスだけである。
